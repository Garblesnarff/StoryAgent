def _extract_title(self, text: str) -> str:
    """Extract title from the beginning of the text."""
    # Look for common title patterns
    title_patterns = [
        r'^(?:Title:|Book:)?\s*([^\n\.]+?)(?:\n|$)',  # Basic title at start
        r'(?:^|\n)(?:Chapter 1|Prologue).*?\n(.*?)(?:\n|$)',  # Title before first chapter
        r'(?:^|\n)([A-Z][^a-z\n]{3,}[A-Z\s]*?)(?:\n|$)'  # ALL CAPS title pattern
    ]
    
    for pattern in title_patterns:
        match = re.search(pattern, text.strip(), re.MULTILINE)
        if match:
            title = match.group(1).strip()
            # Validate title
            if len(title) > 3 and len(title.split()) <= 15:  # Reasonable title length
                return title
    
    return "Untitled Story"  # Default if no valid title found

def _split_into_sentences(self, text: str) -> List[str]:
    """Split text into sentences with improved accuracy."""
    # Handle common abbreviations to avoid false splits
    abbreviations = r'Mr\.|Mrs\.|Dr\.|Ph\.D\.|etc\.|i\.e\.|e\.g\.'
    text = re.sub(f'({abbreviations})', r'\1<POINT>', text)
    
    # Split on sentence boundaries
    sentence_endings = r'(?<=[.!?])\s+(?=[A-Z])'
    sentences = re.split(sentence_endings, text)
    
    # Restore points and clean sentences
    sentences = [s.replace('<POINT>', '.').strip() for s in sentences]
    
    # Filter out invalid sentences
    return [s for s in sentences if self._is_valid_sentence(s)]

def _is_valid_sentence(self, text: str) -> bool:
    """Enhanced sentence validation."""
    if not text or len(text) < 10:  # Too short
        return False
        
    # Must start with capital letter and end with punctuation
    if not re.match(r'^[A-Z].*[.!?]$', text.strip()):
        return False
        
    # Must have reasonable word count
    word_count = len(text.split())
    if word_count < 3 or word_count > 50:  # Adjust thresholds as needed
        return False
        
    # Check for balanced quotes and parentheses
    if text.count('"') % 2 != 0 or text.count('(') != text.count(')'):
        return False
        
    return True

def _create_chunks(self, sentences: List[str], chunk_size: int = 2) -> List[Dict[str, str]]:
    """Create chunks of specified size from sentences."""
    chunks = []
    
    for i in range(0, len(sentences), chunk_size):
        chunk_sentences = sentences[i:i + chunk_size]
        if len(chunk_sentences) == chunk_size or (i + chunk_size >= len(sentences)):
            chunk_text = ' '.join(chunk_sentences)
            chunks.append({
                'text': chunk_text,
                'image_url': None,
                'audio_url': None
            })
    
    return chunks

def _process_text(self, text: str) -> Tuple[str, List[Dict[str, str]]]:
    """Process text with improved chunking and title extraction."""
    try:
        # Clean the text initially
        text = self._clean_text(text)
        
        # Extract title first
        title = self._extract_title(text)
        
        # Use Gemini to extract only story content
        prompt = f'''
        Extract and return ONLY the actual story narrative from this text.
        Exclude the title, table of contents, and any metadata.
        Return only the cleaned narrative text.

        Text to process:
        {text[:8000]}
        '''
        
        response = self.model.generate_content(prompt)
        story_text = response.text
        
        # Clean up the extracted text
        story_text = re.sub(r'^\d+\.\s+', '', story_text, flags=re.MULTILINE)
        story_text = re.sub(r'(?i)(^|\n)(Start|End)\s+of.*?\n', '\n', story_text)
        
        # Split into sentences and create chunks
        sentences = self._split_into_sentences(story_text)
        chunks = self._create_chunks(sentences)
        
        # Add title as first chunk if valid
        if title != "Untitled Story":
            chunks.insert(0, {
                'text': f"Title: {title}",
                'image_url': None,
                'audio_url': None,
                'is_title': True  # Mark as title chunk
            })
        
        logger.info(f"Processed text into {len(chunks)} chunks (including title)")
        return title, chunks[:self.max_paragraphs]
        
    except Exception as e:
        logger.error(f"Error processing text: {str(e)}")
        raise