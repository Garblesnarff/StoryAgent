In app.py, we have:
if __name__ == '__main__':
    try:
        logger.info("Starting Flask server...")
        app.run(host=Config.HOST, port=Config.PORT, debug=True)
    except Exception as e:
        logger.error(f"Failed to start server: {str(e)}")
        raise
While in main.py, we have:
if __name__ == "__main__":
    # Import and run the Flask application
    from app import app
    app.run()
The issues here are:

Multiple Entry Points: Having both app.py and main.py as potential entry points can cause confusion about which port settings are being used.

Port Configuration: The main.py version doesn't specify port settings, while app.py uses Config.PORT.

Port Release: There might be issues with ports not being properly released when the application restarts.

Here's how to fix these issues:

Consolidate the entry points into a single file. I recommend keeping just main.py and updating it like this:
from app import app
import logging
from config import Config
# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
if __name__ == "__main__":
    try:
        logger.info(f"Starting Flask server on port {Config.PORT}...")
        app.run(
            host=Config.HOST,
            port=Config.PORT,
            debug=Config.DEBUG,
            use_reloader=True
        )
    except OSError as e:
        if "Address already in use" in str(e):
            logger.error(f"Port {Config.PORT} is already in use. Please ensure no other instance is running.")
        else:
            logger.error(f"Failed to start server: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error starting server: {str(e)}")
        raise
Add proper port configuration in your Config class:
class Config:
    HOST = '0.0.0.0'  # or '127.0.0.1' for local only
    PORT = int(os.getenv('PORT', 5000))
    DEBUG = os.getenv('FLASK_DEBUG', 'False').lower() in ('true', '1', 't')
Add a cleanup function to ensure ports are properly released:
import atexit
def cleanup():
    logger.info("Cleaning up server resources...")
    # Add any cleanup code here
atexit.register(cleanup)
Add a helper script to force-kill any hanging processes:
def kill_existing_process():
    import os
    import psutil
    
    port = Config.PORT
    for proc in psutil.process_iter(['pid', 'name', 'connections']):
        try:
            for conn in proc.connections():
                if conn.laddr.port == port:
                    os.kill(proc.pid, 9)
                    logger.info(f"Killed process {proc.pid} using port {port}")
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            pass
These changes will:

Ensure consistent port configuration
Provide better error messages for port issues
Clean up resources properly
Handle port conflicts more gracefully