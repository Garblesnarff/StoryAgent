from flask import Blueprint, request, jsonify, session, Response, stream_with_context
from werkzeug.utils import secure_filename
import os
import json
import asyncio
import logging
from pathlib import Path
from services.document_processor import StreamingDocumentProcessor, ProcessingStage
from services.image_generator import ImageGenerator
from services.hume_audio_generator import HumeAudioGenerator

doc_bp = Blueprint('doc', __name__)
doc_processor = StreamingDocumentProcessor()
image_generator = ImageGenerator()
audio_generator = HumeAudioGenerator()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration
ALLOWED_EXTENSIONS = {'pdf', 'txt', 'html', 'md', 'rtf'}
UPLOAD_FOLDER = Path('uploads')
UPLOAD_FOLDER.mkdir(exist_ok=True)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@doc_bp.route('/upload', methods=['POST'])
async def upload_document():
    """Handle document upload and initiate processing"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
        
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
        
    if not allowed_file(file.filename):
        return jsonify({'error': 'Invalid file type'}), 400
        
    try:
        filename = secure_filename(file.filename)
        file_path = UPLOAD_FOLDER / filename
        file.save(file_path)

        async def generate_progress():
            try:
                async for progress in doc_processor.process_document_streaming(str(file_path)):
                    progress_dict = {
                        'stage': progress.stage.value,
                        'progress': progress.progress,
                        'message': progress.message,
                        'details': progress.details
                    }
                    
                    if progress.stage == ProcessingStage.COMPLETE:
                        session['book_data'] = progress.details
                        
                    yield f"data: {json.dumps(progress_dict)}\n\n"
                    
            except Exception as e:
                logger.error(f"Error during document processing: {str(e)}")
                yield f"data: {json.dumps({'error': str(e)})}\n\n"
            finally:
                if file_path.exists():
                    file_path.unlink()

        return Response(
            stream_with_context(generate_progress()),
            mimetype='text/event-stream'
        )
        
    except Exception as e:
        logger.error(f"Error handling upload: {str(e)}")
        if file_path.exists():
            file_path.unlink()
        return jsonify({'error': str(e)}), 500

@doc_bp.route('/generate_media/<int:chapter_num>/<int:paragraph_num>', methods=['POST'])
async def generate_media():
    """Generate image and audio for a specific paragraph"""
    if 'book_data' not in session:
        return jsonify({'error': 'No book data found'}), 404
        
    try:
        data = request.get_json()
        chapter_num = data['chapter_num']
        paragraph_num = data['paragraph_num']
        
        book_data = session['book_data']
        
        # Validate chapter and paragraph numbers
        if chapter_num >= len(book_data['chapters']):
            return jsonify({'error': 'Invalid chapter number'}), 400
            
        chapter = book_data['chapters'][chapter_num]
        if paragraph_num >= len(chapter['paragraphs']):
            return jsonify({'error': 'Invalid paragraph number'}), 400
            
        paragraph = chapter['paragraphs'][paragraph_num]
        
        async def generate():
            try:
                # Generate image
                yield json.dumps({
                    'status': 'generating_image',
                    'message': f'Generating image for chapter {chapter_num + 1}, paragraph {paragraph_num + 1}'
                }) + '\n'
                
                image_url = await image_generator.generate_image(paragraph['image_prompt'])
                paragraph['image_url'] = image_url
                
                yield json.dumps({
                    'status': 'image_complete',
                    'data': {'image_url': image_url}
                }) + '\n'
                
                # Generate audio
                yield json.dumps({
                    'status': 'generating_audio',
                    'message': f'Generating audio for chapter {chapter_num + 1}, paragraph {paragraph_num + 1}'
                }) + '\n'
                
                audio_url = await audio_generator.generate_audio(
                    paragraph['text'],
                    guidance=paragraph['narration_guidance']
                )
                paragraph['audio_url'] = audio_url
                
                yield json.dumps({
                    'status': 'audio_complete',
                    'data': {'audio_url': audio_url}
                }) + '\n'
                
                # Update session
                session['book_data'] = book_data
                
                yield json.dumps({
                    'status': 'complete',
                    'message': 'Media generation complete'
                }) + '\n'
                
            except Exception as e:
                logger.error(f"Error generating media: {str(e)}")
                yield json.dumps({
                    'status': 'error',
                    'message': str(e)
                }) + '\n'
                
        return Response(
            stream_with_context(generate()),
            mimetype='text/event-stream'
        )
        
    except Exception as e:
        logger.error(f"Error handling media generation: {str(e)}")
        return jsonify({'error': str(e)}), 500

@doc_bp.route('/batch_generate/<int:chapter_num>', methods=['POST'])
async def batch_generate_media():
    """Generate media for all paragraphs in a chapter"""
    if 'book_data' not in session:
        return jsonify({'error': 'No book data found'}), 404
        
    try:
        chapter_num = int(request.view_args['chapter_num'])
        book_data = session['book_data']
        
        if chapter_num >= len(book_data['chapters']):
            return jsonify({'error': 'Invalid chapter number'}), 400
            
        chapter = book_data['chapters'][chapter_num]
        
        async def generate_batch():
            try:
                total_paragraphs = len(chapter['paragraphs'])
                
                for i, paragraph in enumerate(chapter['paragraphs']):
                    # Generate image
                    yield json.dumps({
                        'status': 'processing',
                        'progress': (i / total_paragraphs) * 100,
                        'message': f'Processing paragraph {i + 1}/{total_paragraphs}'
                    }) + '\n'
                    
                    # Generate image and audio in parallel
                    image_task = asyncio.create_task(
                        image_generator.generate_image(paragraph['image_prompt'])
                    )
                    audio_task = asyncio.create_task(
                        audio_generator.generate_audio(
                            paragraph['text'],
                            guidance=paragraph['narration_guidance']
                        )
                    )
                    
                    image_url, audio_url = await asyncio.gather(image_task, audio_task)
                    
                    paragraph['image_url'] = image_url
                    paragraph['audio_url'] = audio_url
                    
                    yield json.dumps({
                        'status': 'paragraph_complete',
                        'data': {
                            'paragraph_num': i,
                            'image_url': image_url,
                            'audio_url': audio_url
                        }
                    }) + '\n'
                    
                # Update session
                session['book_data'] = book_data
                
                yield json.dumps({
                    'status': 'complete',
                    'message': f'Completed media generation for chapter {chapter_num + 1}'
                }) + '\n'
                
            except Exception as e:
                logger.error(f"Error in batch generation: {str(e)}")
                yield json.dumps({
                    'status': 'error',
                    'message': str(e)
                }) + '\n'
                
        return Response(
            stream_with_context(generate_batch()),
            mimetype='text/event-stream'
        )
        
    except Exception as e:
        logger.error(f"Error handling batch generation: {str(e)}")
        return jsonify({'error': str(e)}), 500

@doc_bp.route('/book/<int:chapter_num>', methods=['GET'])
def get_chapter():
    """Get chapter data"""
    if 'book_data' not in session:
        return jsonify({'error': 'No book data found'}), 404
        
    try:
        chapter_num = int(request.view_args['chapter_num'])
        book_data = session['book_data']
        
        if chapter_num >= len(book_data['chapters']):
            return jsonify({'error': 'Invalid chapter number'}), 400
            
        chapter = book_data['chapters'][chapter_num]
        return jsonify(chapter)
        
    except Exception as e:
        logger.error(f"Error retrieving chapter: {str(e)}")
        return jsonify({'error': str(e)}), 500

@doc_bp.route('/book/metadata', methods=['GET'])
def get_metadata():
    """Get book metadata"""
    if 'book_data' not in session:
        return jsonify({'error': 'No book data found'}), 404
        
    try:
        book_data = session['book_data']
        return jsonify({
            'metadata': book_data['metadata'],
            'chapter_count': len(book_data['chapters'])
        })
        
    except Exception as e:
        logger.error(f"Error retrieving metadata: {str(e)}")
        return jsonify({'error': str(e)}), 500

@doc_bp.route('/save', methods=['POST'])
def save_progress():
    """Save current progress to database"""
    if 'book_data' not in session:
        return jsonify({'error': 'No book data found'}), 404
        
    try:
        # TODO: Implement database saving
        return jsonify({'success': True, 'message': 'Progress saved'})
        
    except Exception as e:
        logger.error(f"Error saving progress: {str(e)}")
        return jsonify({'error': str(e)}), 500