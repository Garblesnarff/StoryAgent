EVI Python Quickstart Guide

A quickstart guide for implementing the Empathic Voice Interface (EVI) with Python.

This guide provides detailed instructions for integrating EVI into your Python projects using Hume’s Python SDK. It is divided into seven key components:

Environment setup: Download package and system dependencies to run EVI.
Dependency imports: Import all necessary dependencies into your script.
Defining a WebSocketHandler class: Create a class to manage the WebSocket connection.
Authentication: Use your API credentials to authenticate your EVI application.
Connecting to EVI: Set up a secure WebSocket connection to interact with EVI.
Handling audio: Capture audio data from an input device, and play audio produced by EVI.
Asynchronous event loop: Initiate and manage an asynchronous event loop that handles simultaneous, real-time execution of message processing and audio playback.
To see a full implementation within a terminal application, visit our API examples repository on GitHub: evi-python-example

Hume’s Python SDK supports EVI using Python versions 3.9, 3.10, and 3.11 on macOS and Linux platforms. The full specification be found on the Python SDK GitHub page.

1
Environment setup
Before starting the project, it is essential to set up the development environment.

Creating a virtual environment (optional)
Setting up a virtual environment is a best practice to isolate your project’s dependencies from your global Python installation, avoiding potential conflicts.

You can create a virtual environment using either Python’s built-in venv module or the conda environment manager. See instructions for both below:

venv
conda
Create the virtual environment.
Note that when you create a virtual environment using Python’s built-in venv tool, the virtual environment will use the same Python version as the global Python installation that you used to create it.

Creating the virtual environment with venv

python -m venv evi-env
Activate the virtual environment using the appropriate command for your system platform.
Activating the virtual environment with venv

source evi-env/bin/activate
The code above demonstrates virtual environment activation on a POSIX platform with a bash/zsh shell. Visit the venv documentation to learn more about using venv on your platform.

Package dependenices
There are two package dependencies for using EVI:

Hume Python SDK (required)
The hume[microphone] package contains the Hume Python SDK. This guide employs EVI’s WebSocket and message handling infrastructure as well as various asynchronous programming and audio utilities.

Installing the Hume Python SDK package

pip install "hume[microphone]"
Environment variables (recommended)
The python-dotenv package contains the logic for using environment variables to store and load sensitive variables such as API credentials from a .env file.

Installing the environment variable package

pip install python-dotenv
In sample code snippets below, the API key, Secret key, and an EVI configuration id have been saved to environment variables.

While not strictly required, using environment variables is considered best practice because it keeps sensitive information like API keys and configuration settings separate from your codebase. This not only enhances security but also makes your application more flexible and easier to manage across different environments.

System dependencies
For audio playback and processing, additional system-level dependencies are required. Below are download instructions for each supported operating system:

macOS
Linux
To ensure audio playback functionality, macOS users will need to install ffmpeg, a powerful multimedia framework that handles audio and video processing.

A common way to install ffmpeg on macOS is by using a package manager such as Homebrew. To do so, follow these steps:

Install Homebrew onto your system according to the instructions on the Homebrew website.

Once Homebrew is installed, you can install ffmpeg with brew:

Installing ffmpeg with Homebrew

brew install ffmpeg
If you prefer not to use Homebrew, you can download a pre-built ffmpeg binary from the ffmpeg website or use other package managers like MacPorts.

2
Dependency imports
The following import statements are used in the example project to handle asynchronous operations, environment variables, audio processing, and communication with the Hume API:

Import statements
Statement explanations
Imports

import asyncio
import base64
import datetime
import os
from dotenv import load_dotenv
from hume.client import AsyncHumeClient
from hume.empathic_voice.chat.socket_client import ChatConnectOptions, ChatWebsocketConnection
from hume.empathic_voice.chat.types import SubscribeEvent
from hume.empathic_voice.types import UserInput
from hume.core.api_error import ApiError
from hume import MicrophoneInterface, Stream
3
Defining a WebSocketHandler class
Next, we define a WebSocketHandler class to encapsulate WebSocket functionality in one organized component. The handler allows us to implement application-specific behavior upon the socket opening, closing, receiving messages, and handling errors. It also manages the continuous audio stream from a microphone.

By using a class, you can maintain the WebSocket connection and audio stream state in one place, making it simpler to manage both real-time communication and audio processing.

Below are the key methods:

Method	Description
__init__()	Initializes the handler, setting up placeholders for the WebSocket connection.
set_socket(socket: ChatWebsocketConnection)	Associates the WebSocket connection with the handler.
on_open()	Called when the WebSocket connection is established, enabling any necessary initialization.
on_message(data: SubscribeEvent)	Handles incoming messages from the WebSocket, processing different types of messages.
on_close()	Invoked when the WebSocket connection is closed, allowing for cleanup operations.
on_error(error: Exception)	Manages errors that occur during WebSocket communication, providing basic error logging.

Example WebSocketHandler Structure
4
Authentication
In order to establish an authenticated connection, we instantiate the Hume client with our API key and include our Secret key in the query parameters passed into the WebSocket connection.

You can obtain your API credentials by logging into the Hume Platform and visiting the API keys page.

Authenticating EVI

async def main() -> None:
  # Retrieve any environment variables stored in the .env file
  load_dotenv()
  # Retrieve the API key, Secret key, and EVI config id from the environment variables
  HUME_API_KEY = os.getenv("HUME_API_KEY")
  HUME_SECRET_KEY = os.getenv("HUME_SECRET_KEY")
  HUME_CONFIG_ID = os.getenv("HUME_CONFIG_ID")
  # Initialize the asynchronous client, authenticating with your API key
  client = AsyncHumeClient(api_key=HUME_API_KEY)
  # Define options for the WebSocket connection, such as an EVI config id and a secret key for token authentication
  options = ChatConnectOptions(config_id=HUME_CONFIG_ID, secret_key=HUME_SECRET_KEY)
  
  # ...
5
Connecting to EVI
With the Hume client instantiated with our credentials, we can now establish an authenticated WebSocket connection with EVI and pass in our handlers.

Connecting to EVI

async def main() -> None:
  # ...
  # Define options for the WebSocket connection, such as an EVI config id and a secret key for token authentication
  options = ChatConnectOptions(config_id=HUME_CONFIG_ID, secret_key=HUME_SECRET_KEY)
  # Instantiate the WebSocketHandler
  websocket_handler = WebSocketHandler()
  # Open the WebSocket connection with the configuration options and the handler's functions
    async with client.empathic_voice.chat.connect_with_callbacks(
      options=options,
      on_open=websocket_handler.on_open,
      on_message=websocket_handler.on_message,
      on_close=websocket_handler.on_close,
      on_error=websocket_handler.on_error
    ) as socket:
    
      # Set the socket instance in the handler
      websocket_handler.set_socket(socket)
      # ...